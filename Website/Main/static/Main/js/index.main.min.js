/*! For license information please see index.main.min.js.LICENSE.txt */
(()=>{var __webpack_modules__={"./static/Components/Base/media_loader.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mediaLoad: () => (/* binding */ mediaLoad)\n/* harmony export */ });\nfunction mediaLoad() {\n  let onMediaUploaded = new CustomEvent('onMediaUploaded');\n  function WaitImageToUpload(image) {\n    var options = {\n      threshold: 0\n    };\n    var image_observer = new IntersectionObserver((entries, observer) => {\n      // Loop through the entries\n      for (const entry of entries) {\n        // Check if the entry is intersecting the viewport\n        if (entry.isIntersecting) {\n          image.setAttribute('src', image.getAttribute('data-src'));\n          image.classList.add('loader');\n          image_observer.disconnect();\n        }\n      }\n    }, options);\n    image_observer.observe(image);\n  }\n\n  // Callback function to execute when mutations are observed\n  function WaitMediaToAppear(mutationList, observer) {\n    for (const mutation of mutationList) {\n      if (mutation.addedNodes.length > 0) {\n        document.dispatchEvent(onMediaUploaded);\n        const images = mutation.target.querySelectorAll(\".dynamic_image\");\n        images.forEach(image => {\n          WaitImageToUpload(image);\n        });\n      }\n    }\n  }\n  ;\n\n  // Observe only those elements that I have explicitly assign\n  // This observe those elements that gonna have new children via ajax or\n  // Other technologies\n  const observedElements = document.querySelectorAll(\".toObserve\");\n  // This observer have to observe only those elements that have new children\n  const config = {\n    childList: true\n  };\n  // Set up callback\n  const observer = new MutationObserver(WaitMediaToAppear);\n  // Start observing the target node for configured mutations\n  observedElements.forEach(el => {\n    observer.observe(el, config);\n  });\n\n  // Observe images if they are intersecting with main viewport\n  const images = document.querySelectorAll(\".dynamic_image\");\n  images.forEach(image => {\n    image.addEventListener('error', event => {\n      event.target.src = `${PATH}image-not-found.svg`;\n      event.onerror = null;\n    });\n    WaitImageToUpload(image);\n  });\n}\n\n//# sourceURL=webpack://main/./static/Components/Base/media_loader.js?\n}")},"./static/Components/Containers/Carousel/carousel.js":()=>{eval("{const slides = document.querySelectorAll('.slide');\nconst sliderButtons = document.querySelectorAll('.slider-button');\nconst prevButton = document.querySelector('.prev');\nconst nextButton = document.querySelector('.next');\nconst disableButtons = (prevButton, nextButton, index) => {\n  const lastSlideIndex = slides.length - 1;\n  const firstSlideIndex = 0;\n  if (index === lastSlideIndex) {\n    nextButton.setAttribute('aria-disabled', true);\n    nextButton.setAttribute('aria-label', 'no next slide available');\n  } else if (index === firstSlideIndex) {\n    prevButton.setAttribute('aria-disabled', true);\n    prevButton.setAttribute('aria-label', 'no previous slide available');\n  } else {\n    nextButton.removeAttribute('aria-disabled');\n    prevButton.removeAttribute('aria-disabled');\n    nextButton.setAttribute('aria-label', 'next slide');\n    prevButton.setAttribute('aria-label', 'previous slide');\n  }\n};\nconst controlSlider = e => {\n  let currentIndex = 0;\n  slides.forEach((slide, index) => {\n    const hiddenAttribute = slide.getAttribute('aria-hidden');\n    if (hiddenAttribute === 'false') currentIndex = index;\n  });\n  var slideToActivate = null;\n  if (e.target.classList.contains('next')) {\n    slideToActivate = slides[currentIndex + 1];\n  } else {\n    if (e.target.classList.contains('prev')) {\n      slideToActivate = slides[currentIndex - 1];\n    }\n  }\n  if (slideToActivate !== undefined) {\n    // hide current slide\n    slides[currentIndex].setAttribute('aria-hidden', true);\n    slides[currentIndex].removeAttribute('tabindex');\n\n    // disable buttons if needed\n    const activateIndex = [...slides].indexOf(slideToActivate);\n    disableButtons(prevButton, nextButton, activateIndex);\n\n    // set active slide\n    slideToActivate.setAttribute('aria-hidden', false);\n    slideToActivate.setAttribute('tabindex', 0);\n    slideToActivate.focus();\n  }\n};\nsliderButtons.forEach(button => {\n  button.addEventListener('click', controlSlider);\n});\n\n// ---------------------------------\n// Lazy Load Images ----------------\n// ---------------------------------\n// to do: only load the first three or so images when the carousel gets into the viewport. then at every right click load another image - if the urser isnt going to get to all the images whats the point in loading them\nconst lazySlideImages = document.querySelectorAll('.slide.lazy-img');\nconst imageObs = new IntersectionObserver((entries, observe) => {\n  entries.forEach(entry => {\n    if (entry.isIntersecting) {\n      const image = entry.target;\n      image.classList.remove('lazy-img');\n      imageObs.unobserve(image);\n    }\n  });\n});\nlazySlideImages.forEach(slideImage => {\n  imageObs.observe(slideImage);\n});\n\n// to do\n// make it draggable\n\n//# sourceURL=webpack://main/./static/Components/Containers/Carousel/carousel.js?\n}")},"./static/Components/Containers/Tabs/tabs_v2.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initTabs: () => (/* binding */ initTabs)\n/* harmony export */ });\nfunction onTab(tabnavitems, tab) {\n  // Меняем состояние\n  history.pushState(null, '', `${tab.getAttribute('href')}`);\n  const targetId = tab.getAttribute('href').substring(1);\n  const targetElement = document.getElementById(targetId);\n  if (targetElement) {\n    // Плавный скролл к элементу, чтобы он появился на экране\n    targetElement.scrollIntoView({\n      behavior: 'smooth',\n      block: 'nearest'\n    });\n  }\n  tabnavitems.forEach(tabitem => {\n    tabitem.classList.remove('ttw-tab_active');\n    tabitem.classList.remove('ref-int_no-sign');\n  });\n  tab.classList.add('ttw-tab_active');\n  tab.classList.add('ref-int_no-sign');\n}\n// grab and stash elements\nfunction initTabs() {\n  const tabgroups = document.querySelectorAll('tabs');\n  tabgroups.forEach(tabgroup => {\n    var anchor = window.location.hash.substring(1);\n    let previousScrollLeft = 0;\n    var tabnav = tabgroup.querySelector(':scope .ttw-tabs-navigation');\n    var tabnext_button_nav = tabnav.querySelector(':scope .ttw-tabs-next-tab');\n    var tabprev_button_nav = tabnav.querySelector(':scope .ttw-tabs-prev-tab');\n    var tabbody = tabgroup.querySelector(':scope .ttw-tabs-body');\n    var tabnavitems = tabnav.querySelectorAll(':scope .ttw-tabs-navigation-tab ');\n    /*\r\n    for each nav link\r\n    - animate color based on the scroll timeline\r\n    - color is active when its the current index*/\n    tabnavitems.forEach(navitem => {\n      navitem.addEventListener('click', event => {\n        // Предотвращаем скачок к цели\n        event.preventDefault();\n        navitem.scrollIntoView({\n          behavior: 'smooth',\n          block: 'nearest'\n        });\n        onTab(tabnavitems, navitem);\n      });\n      if (anchor === navitem.getAttribute('href').substring(1)) {\n        onTab(tabnavitems, navitem);\n      }\n      // Добавить переключение при скролинге при помощи клавиатуры\n    });\n    tabbody.addEventListener('scroll', event => {\n      var anchor = window.location.hash;\n      var navitem = tabnav.firstElementChild;\n      if (anchor.length > 0) {\n        var navitem = tabnav.querySelector(`:scope a[href=\"${anchor}\"]`);\n      }\n      const currentScrollLeft = tabbody.scrollLeft;\n      // Прокрутка на право\n      if (currentScrollLeft > previousScrollLeft) {\n        if (navitem.nextElementSibling) {\n          if (!navitem.nextElementSibling.classList.contains('ttw-tabs-navigation-buttons')) {\n            navitem.nextElementSibling.scrollIntoView({\n              behavior: 'smooth',\n              block: 'nearest'\n            });\n            onTab(tabnavitems, navitem.nextElementSibling);\n          }\n        }\n        // Прокрутка на лево\n      } else if (currentScrollLeft < previousScrollLeft) {\n        if (navitem.previousElementSibling) {\n          if (!navitem.previousElementSibling.classList.contains('ttw-tabs-navigation-buttons')) {\n            navitem.previousElementSibling.scrollIntoView({\n              behavior: 'smooth',\n              block: 'nearest'\n            });\n            onTab(tabnavitems, navitem.previousElementSibling);\n          }\n        }\n      }\n      previousScrollLeft = currentScrollLeft;\n    });\n    // Добавим возможность переключать табы по кнопкам\n    if (tabnext_button_nav) {\n      tabnext_button_nav.addEventListener('click', event => {\n        var anchor = window.location.hash;\n        var navitem = tabnav.firstElementChild;\n        if (anchor.length > 0) {\n          var toProceed = false;\n          tabnavitems.forEach(item => {\n            if (item.getAttribute('href') === anchor) {\n              toProceed = true;\n            }\n          });\n          if (toProceed) var navitem = tabnav.querySelector(`:scope a[href=\"${anchor}\"]`);\n        }\n        if (navitem.nextElementSibling) {\n          if (!navitem.nextElementSibling.classList.contains('ttw-tabs-navigation-buttons')) {\n            navitem.nextElementSibling.scrollIntoView({\n              behavior: 'smooth',\n              block: 'nearest'\n            });\n            onTab(tabnavitems, navitem.nextElementSibling);\n          }\n        }\n      });\n    }\n    // Добавим возможность переключать табы по кнопкам\n    if (tabprev_button_nav) {\n      tabprev_button_nav.addEventListener('click', event => {\n        var anchor = window.location.hash;\n        var navitem = tabnav.firstElementChild;\n        if (anchor.length > 0) {\n          var toProceed = false;\n          tabnavitems.forEach(item => {\n            if (item.getAttribute('href') === anchor) {\n              toProceed = true;\n            }\n          });\n          if (toProceed) {\n            var navitem = tabnav.querySelector(`:scope a[href=\"${anchor}\"]`);\n          }\n        }\n        if (navitem.previousElementSibling) {\n          if (!navitem.previousElementSibling.classList.contains('ttw-tabs-navigation-buttons')) {\n            navitem.previousElementSibling.scrollIntoView({\n              behavior: 'smooth',\n              block: 'nearest'\n            });\n            onTab(tabnavitems, navitem.previousElementSibling);\n          }\n        }\n      });\n    }\n  });\n}\n\n//# sourceURL=webpack://main/./static/Components/Containers/Tabs/tabs_v2.js?\n}")},"./static/Main/js/index.main.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Components_Containers_Carousel_carousel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Components/Containers/Carousel/carousel.js */ "./static/Components/Containers/Carousel/carousel.js");\n/* harmony import */ var _Components_Containers_Carousel_carousel_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Components_Containers_Carousel_carousel_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Components_Containers_Tabs_tabs_v2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Components/Containers/Tabs/tabs_v2.js */ "./static/Components/Containers/Tabs/tabs_v2.js");\n/* harmony import */ var _Components_Base_media_loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Components/Base/media_loader.js */ "./static/Components/Base/media_loader.js");\n\n\n\nconst csrftoken = document.querySelector(\'[name=csrfmiddlewaretoken]\').value;\nfunction toFixHeight() {\n  document.querySelectorAll(\'.resize-block\').forEach(button => {\n    button.addEventListener(\'click\', event => {\n      var refElementId = button.dataset.refElementId;\n      var height = document.querySelector(`#${refElementId}`).getBoundingClientRect().height + "px";\n      var refSelectorId = button.dataset.refSelectorId;\n      var selector = document.querySelector(`#${refSelectorId}`);\n      selector.style.height = height;\n    });\n  });\n}\nif (document.readyState === "loading") {\n  document.addEventListener("DOMContentLoaded", _Components_Base_media_loader_js__WEBPACK_IMPORTED_MODULE_2__.mediaLoad);\n  document.addEventListener("DOMContentLoaded", _Components_Containers_Tabs_tabs_v2_js__WEBPACK_IMPORTED_MODULE_1__.initTabs);\n  toFixHeight();\n} else {\n  (0,_Components_Base_media_loader_js__WEBPACK_IMPORTED_MODULE_2__.mediaLoad)();\n  (0,_Components_Containers_Tabs_tabs_v2_js__WEBPACK_IMPORTED_MODULE_1__.initTabs)();\n  toFixHeight();\n}\n\n//# sourceURL=webpack://main/./static/Main/js/index.main.js?\n}')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./static/Main/js/index.main.js")})();