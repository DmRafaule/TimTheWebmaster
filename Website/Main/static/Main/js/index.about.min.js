/*! For license information please see index.about.min.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={"./static/Components/Base/media_loader.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mediaLoad: () => (/* binding */ mediaLoad)\n/* harmony export */ });\nfunction mediaLoad() {\n  let onMediaUploaded = new CustomEvent('onMediaUploaded');\n  function WaitImageToUpload(image) {\n    var options = {\n      threshold: 0\n    };\n    var image_observer = new IntersectionObserver((entries, observer) => {\n      // Loop through the entries\n      for (const entry of entries) {\n        // Check if the entry is intersecting the viewport\n        if (entry.isIntersecting) {\n          image.setAttribute('src', image.getAttribute('data-src'));\n          image.classList.add('loader');\n          image_observer.disconnect();\n        }\n      }\n    }, options);\n    image_observer.observe(image);\n  }\n\n  // Callback function to execute when mutations are observed\n  function WaitMediaToAppear(mutationList, observer) {\n    for (const mutation of mutationList) {\n      if (mutation.addedNodes.length > 0) {\n        document.dispatchEvent(onMediaUploaded);\n        const images = mutation.target.querySelectorAll(\".dynamic_image\");\n        images.forEach(image => {\n          WaitImageToUpload(image);\n        });\n      }\n    }\n  }\n  ;\n\n  // Observe only those elements that I have explicitly assign\n  // This observe those elements that gonna have new children via ajax or\n  // Other technologies\n  const observedElements = document.querySelectorAll(\".toObserve\");\n  // This observer have to observe only those elements that have new children\n  const config = {\n    childList: true\n  };\n  // Set up callback\n  const observer = new MutationObserver(WaitMediaToAppear);\n  // Start observing the target node for configured mutations\n  observedElements.forEach(el => {\n    observer.observe(el, config);\n  });\n\n  // Observe images if they are intersecting with main viewport\n  const images = document.querySelectorAll(\".dynamic_image\");\n  images.forEach(image => {\n    image.addEventListener('error', event => {\n      event.target.src = `${PATH}image-not-found.svg`;\n      event.onerror = null;\n    });\n    WaitImageToUpload(image);\n  });\n}\n\n//# sourceURL=webpack://main/./static/Components/Base/media_loader.js?\n}")},"./static/Main/js/index.about.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Components_Base_media_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Components/Base/media_loader.js */ "./static/Components/Base/media_loader.js");\n\nif (document.readyState === "loading") {\n  document.addEventListener("DOMContentLoaded", _Components_Base_media_loader_js__WEBPACK_IMPORTED_MODULE_0__.mediaLoad);\n} else {\n  (0,_Components_Base_media_loader_js__WEBPACK_IMPORTED_MODULE_0__.mediaLoad)();\n}\n\n//# sourceURL=webpack://main/./static/Main/js/index.about.js?\n}')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var a=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](a,a.exports,__webpack_require__),a.exports}__webpack_require__.d=(e,n)=>{for(var a in n)__webpack_require__.o(n,a)&&!__webpack_require__.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./static/Main/js/index.about.js")})();